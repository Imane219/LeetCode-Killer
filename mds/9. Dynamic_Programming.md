# Dynamic Programming

An algorithm that simplifies a complicated problem by breaking it down into simpler sub-problems in a recursive manner. The local optimum can lead to global optimum.

DP can avoid the repeated calculation of one situation in recurse. 

Trace back + record the computation results (memorized search) -> DP

## In total

1. Create a dp[] to record the recursive results. -> Figure out the dp[i]'s meaning.
2. Conclude the recurrence relation.
3. Initialize the dp[].
4. 

### Tips

- Like problem 45, update the **end condition for one step** during iteration.
- The **changes of the summary** can also be used to judge.
- **Traversing twice** is a easy way to process sequences with ascending and descending.

## Problems

#### one dimensional `dp[]`

> [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/) / Also Fibonacci.

- **dp[i]**: the number of ways to achieve the i-th stair.
- **state transition**: dp[i] = dp[i-1] + dp[i-2]. Only need to record the previous two num.
- **initialize**: dp[0] -> meaningless; dp[1] -> 1; dp[2] -> 2

#### two dimensional `dp[][]`

> [63. Unique Paths 2](https://leetcode.com/problems/unique-paths-ii/description/)

Two dimensional `dp[][]` to record the paths to each grid. Space complexity: $O(mn)$

-> Space $O(n)$ optimization: **scrolling array**.

Just record one row dp[n]. For the current `grid[i][j]`, dp[j] is the path num of the `grid[i-1][j]`, dp[j-1] if the path num of the `grid[i][j-1]`. So **dp[j] += dp[j-1]** can update the dp.

- **dp[j]**: the number of paths of the j-th grid of the current row.
- **state transition**: dp[j] += dp[j-1]
- **initialize**: dp[0] = 1 if not obstacle else 0

#### state transition

> [343. Integer Break](https://leetcode.com/problems/integer-break/description/)

- **dp[i]**: the maximum product of integer i.
- **state transition**: $dp[i] = max(dp[i],j*dp[i-j],j*(i-j))$ for j in range(1,i).
  - for integer i > 4, dp[i] > i
  - for integer i <= 3, dp[i] < i. as dp[2]=1; dp[3]=2.
  - the item dp[i] in the max() is to update the dp during the iteration of j.
- **initialize**: `dp = [0]*(n+1)`

